diff --git a/samples/bluetooth/peripheral_hids_keyboard/prj.conf b/samples/bluetooth/peripheral_hids_keyboard/prj.conf
index 57b7f262e2..0d17876c1b 100644
--- a/samples/bluetooth/peripheral_hids_keyboard/prj.conf
+++ b/samples/bluetooth/peripheral_hids_keyboard/prj.conf
@@ -11,7 +11,7 @@ CONFIG_BT_MAX_PAIRED=2
 CONFIG_BT_SMP=y
 CONFIG_BT_ATT_TX_COUNT=5
 CONFIG_BT_PERIPHERAL=y
-CONFIG_BT_DEVICE_NAME="Nordic_HIDS_keyboard"
+CONFIG_BT_DEVICE_NAME="Nordic_HIDS_keyboard_TEST"
 CONFIG_BT_DEVICE_APPEARANCE=961
 
 CONFIG_BT_BAS=y
@@ -39,3 +39,9 @@ CONFIG_FLASH_PAGE_LAYOUT=y
 CONFIG_FLASH_MAP=y
 
 CONFIG_DK_LIBRARY=y
+
+CONFIG_BT_USER_PHY_UPDATE=y
+CONFIG_BT_CTLR_PHY_2M=y
+
+CONFIG_BT_LOG_SNIFFER_INFO=y
+CONFIG_BT_BUF_ACL_TX_COUNT=2
\ No newline at end of file
diff --git a/samples/bluetooth/peripheral_hids_keyboard/src/main.c b/samples/bluetooth/peripheral_hids_keyboard/src/main.c
index cdc19bb1b9..355f475820 100644
--- a/samples/bluetooth/peripheral_hids_keyboard/src/main.c
+++ b/samples/bluetooth/peripheral_hids_keyboard/src/main.c
@@ -54,6 +54,7 @@
 #define NFC_LED	       DK_LED4
 #define KEY_TEXT_MASK  DK_BTN1_MSK
 #define KEY_SHIFT_MASK DK_BTN2_MSK
+#define KEY_9320_MASK  DK_BTN3_MSK
 #define KEY_ADV_MASK   DK_BTN4_MSK
 
 /* Key used to accept or reject passkey value */
@@ -161,6 +162,16 @@ struct pairing_data_mitm {
 	unsigned int passkey;
 };
 
+/* test flags */
+#define INTERVAL_7_5MS  0x06
+#define REPORT_NOS      1024
+
+static bool request_1m_phy = false;
+static bool request_2m_phy = false;
+static bool request_conn_param_update = false;
+static bool continious_report_flag = false;
+static volatile bool notification_cb_flag = true;
+
 K_MSGQ_DEFINE(mitm_queue,
 	      sizeof(struct pairing_data_mitm),
 	      CONFIG_BT_HIDS_MAX_CLIENT_COUNT,
@@ -343,9 +354,34 @@ static void security_changed(struct bt_conn *conn, bt_security_t level,
 	}
 }
 
+static bool le_param_req(struct bt_conn *conn,
+			 struct bt_le_conn_param *param)
+{
+	printk("LE param request: %u %u %u\n", param->interval_min,
+	       param->interval_max, param->latency);
+
+	return true;
+}
+
+static void le_param_updated(struct bt_conn *conn, uint16_t interval,
+			      uint16_t latency, uint16_t timeout)
+{
+	printk("LE param updated: %u %u %u\n", interval, latency, timeout);
+}
+
+static void le_phy_updated(struct bt_conn *conn,
+			    struct bt_conn_le_phy_info *param)
+{
+	printk("LE PHY updated: TX PHY %u, RX PHY %u\n", param->tx_phy,
+	       param->rx_phy);
+}
+
 BT_CONN_CB_DEFINE(conn_callbacks) = {
 	.connected = connected,
 	.disconnected = disconnected,
+	.le_param_req = le_param_req,
+	.le_param_updated = le_param_updated,
+	.le_phy_updated = le_phy_updated,
 	.security_changed = security_changed,
 };
 
@@ -531,7 +567,7 @@ static void auth_passkey_confirm(struct bt_conn *conn, unsigned int passkey)
 
 	pairing_data.conn    = bt_conn_ref(conn);
 	pairing_data.passkey = passkey;
-
+	printk("auth_passkey_confirm : %06u\n", passkey);		//test print
 	err = k_msgq_put(&mitm_queue, &pairing_data, K_NO_WAIT);
 	if (err) {
 		printk("Pairing queue is full. Purge previous data.\n");
@@ -594,7 +630,8 @@ static void pairing_complete(struct bt_conn *conn, bool bonded)
 	char addr[BT_ADDR_LE_STR_LEN];
 
 	bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
-
+	request_2m_phy = true;
+	request_conn_param_update = true;
 	printk("Pairing completed: %s, bonded: %d\n", addr, bonded);
 }
 
@@ -798,6 +835,51 @@ static int hid_buttons_release(const uint8_t *keys, size_t cnt)
 	return key_report_send();
 }
 
+void notify_complete_cb (struct bt_conn *conn, void *user_data){
+	notification_cb_flag = true;
+}
+
+static void hid_report_relay(uint8_t *data_in, size_t len)
+{
+	int err = 0;
+	hid_keyboard_state.keys_state[0] = *data_in;
+	uint8_t  data[INPUT_REPORT_KEYS_MAX_LEN];
+	uint8_t *key_data;
+	const uint8_t *key_state;
+	key_state = hid_keyboard_state.keys_state;
+	data[0] = 0;
+	data[1] = 0;
+	key_data = &data[2];
+	size_t n;
+	uint16_t count = REPORT_NOS;
+
+	for (n = 0; n < KEY_PRESS_MAX; ++n) {
+		*key_data++ = *key_state++;
+	}
+	for (size_t i = 0; i < CONFIG_BT_HIDS_MAX_CLIENT_COUNT; i++) {
+		if (conn_mode[i].conn) {
+			if (conn_mode[i].in_boot_mode) {
+				printk("Boot mode not supported\n");
+				return;
+			}
+			else {
+				while(count){
+					if(notification_cb_flag) {
+						count--;
+						notification_cb_flag = false;
+						err = bt_hids_inp_rep_send(&hids_obj, conn_mode[i].conn,
+							INPUT_REP_KEYS_IDX, data,
+							sizeof(data), notify_complete_cb);
+
+						if (err) {
+							printk("Key report send error: %d\n", err);
+						}			
+					}
+				}
+			}
+		}
+	}
+}
 
 static void button_text_changed(bool down)
 {
@@ -832,7 +914,7 @@ static void num_comp_reply(bool accept)
 	if (k_msgq_get(&mitm_queue, &pairing_data, K_NO_WAIT) != 0) {
 		return;
 	}
-
+	printk ("num_comp_reply passkey: %d\n", pairing_data.passkey);
 	conn = pairing_data.conn;
 
 	if (accept) {
@@ -887,6 +969,9 @@ static void button_changed(uint32_t button_state, uint32_t has_changed)
 	if (has_changed & KEY_SHIFT_MASK) {
 		button_shift_changed((button_state & KEY_SHIFT_MASK) != 0);
 	}
+	if (has_changed & KEY_9320_MASK) {
+		continious_report_flag = true;
+	}
 #if CONFIG_NFC_OOB_PAIRING
 	if (has_changed & KEY_ADV_MASK) {
 		size_t i;
@@ -980,6 +1065,53 @@ int main(void)
 	k_work_init(&pairing_work, pairing_process);
 
 	for (;;) {
+		if(request_2m_phy) {
+			printk("Update phy to 2M\n");
+			struct bt_conn *conn = NULL;
+			for (size_t i = 0; i < CONFIG_BT_HIDS_MAX_CLIENT_COUNT; i++) {
+				if (conn_mode[i].conn) {
+					conn = conn_mode[i].conn;	//retrive conn obj reference
+					break;
+				}
+			}
+			if (conn) {
+				struct bt_conn_le_phy_param *phy = BT_CONN_LE_PHY_PARAM_2M;
+				uint8_t err;
+				err = bt_conn_le_phy_update(conn, phy);
+				if (err) {
+					printk("PHY update failed: %d\n", err);
+				}
+				request_2m_phy = false;
+			}
+		}
+		if(request_conn_param_update) {
+			printk("Update Connection parameter\n");
+			struct bt_conn *conn = NULL;
+			for (size_t i = 0; i < CONFIG_BT_HIDS_MAX_CLIENT_COUNT; i++) {
+				if (conn_mode[i].conn) {
+					conn = conn_mode[i].conn;	//retrive conn obj reference
+					break;
+				}
+			}
+			if (conn) {
+				struct bt_le_conn_param *param = BT_LE_CONN_PARAM(INTERVAL_7_5MS, INTERVAL_7_5MS, 44, 1980);
+				
+				uint8_t err;
+				err = bt_conn_le_param_update(conn, param);
+				if (err) {
+					printk("Connection parameter update failed: %d\n", err);
+				}
+				request_conn_param_update = false;
+			}
+		}
+		
+		if(continious_report_flag){
+			static const uint8_t *data = hello_world_str;
+			printk("continious_report_flag\n");
+			hid_report_relay(data, 1);
+			hid_buttons_release(data, 1);
+			continious_report_flag = false;
+		}
 		if (is_adv) {
 			dk_set_led(ADV_STATUS_LED, (++blink_status) % 2);
 		} else {
@@ -987,6 +1119,6 @@ int main(void)
 		}
 		k_sleep(K_MSEC(ADV_LED_BLINK_INTERVAL));
 		/* Battery level simulation */
-		bas_notify();
+		// bas_notify();
 	}
 }
